// Copyright 2018 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

#pragma once

#include "vec.isph"

// Compute the channel block size in bytes
#if defined(OIDN_ARCH_AVX512)
  #define BLOCKC_BYTESIZE 64
#elif defined(OIDN_ARCH_AVX2) || defined(OIDN_ARCH_SSE4) || defined(OIDN_ARCH_NEON)
  #define BLOCKC_BYTESIZE 32
#else
  #error "Unsupported architecture"
#endif

template<typename T>
inline uniform int getBlockC()
{
  return BLOCKC_BYTESIZE / sizeof(uniform T);
}

// -----------------------------------------------------------------------------------------------
// TensorAccessor1D
// -----------------------------------------------------------------------------------------------

struct TensorAccessor1D
{
  uniform int8* uniform ptr;
  uniform int X;
};

template<typename T>
inline uniform int8* uniform Tensor_getPtr(const uniform TensorAccessor1D& acc, uniform int x)
{
  const uniform uint32 xByteStride = sizeof(uniform T);
  return acc.ptr + (uniform uint32)x * xByteStride;
}

// -----------------------------------------------------------------------------------------------
// TensorAccessor3D_chw
// -----------------------------------------------------------------------------------------------

// Tensor in chw layout
struct TensorAccessor3D_chw
{
  uniform int8* uniform ptr;
  uniform uint32 hByteStride;
  uniform uint32 cByteStride;
  uniform int C, H, W;
};

template<typename T>
inline uniform int8* uniform Tensor_getPtr(const uniform TensorAccessor3D_chw& acc,
                                            uniform int c, uniform int h, uniform int w)
{
  const uniform uint32 wByteStride = sizeof(uniform T);

  uniform uint32 offset = (uniform uint32)c * acc.cByteStride +
                          (uniform uint32)h * acc.hByteStride +
                          (uniform uint32)w * wByteStride;

  return acc.ptr + offset;
}

template<typename T>
inline uniform int8* varying Tensor_getPtr(const uniform TensorAccessor3D_chw& acc,
                                            uniform int c, uniform int h, int w)
{
  const uniform uint32 wByteStride = sizeof(uniform T);

  uint32 offset = (uniform uint32)c * acc.cByteStride +
                  (uniform uint32)h * acc.hByteStride +
                  (uint32)w         * wByteStride;

  return acc.ptr + offset;
}

// -----------------------------------------------------------------------------------------------
// TensorAccessor3D_ChwBc
// -----------------------------------------------------------------------------------------------

// Tensor in ChwBc layout (blocked)
struct TensorAccessor3D_ChwBc
{
  uniform int8* uniform ptr;
  uniform uint32 hByteStride;
  uniform uint32 CByteStride;
  uniform int C, H, W;
};

template<typename T>
inline uniform int8* uniform Tensor_getPtr(const uniform TensorAccessor3D_ChwBc& acc,
                                            uniform int c, uniform int h, uniform int w)
{
  const uniform uint32 B = getBlockC<T>();
  const uniform uint32 cByteStride = sizeof(uniform T);
  const uniform uint32 wByteStride = B * cByteStride;

  uniform uint32 offset = ((uniform uint32)c / B) * acc.CByteStride +
                          ((uniform uint32)c % B) * cByteStride +
                          (uniform uint32)h       * acc.hByteStride +
                          (uniform uint32)w       * wByteStride;

  return acc.ptr + offset;
}

template<typename T>
inline uniform int8* varying Tensor_getPtr(const uniform TensorAccessor3D_ChwBc& acc,
                                            uniform int c, uniform int h, int w)
{
  const uniform uint32 B = getBlockC<T>();
  const uniform uint32 cByteStride = sizeof(uniform T);
  const uniform uint32 wByteStride = B * cByteStride;

  uint32 offset = ((uniform uint32)c / B) * acc.CByteStride +
                  ((uniform uint32)c % B) * cByteStride +
                  (uniform uint32)h       * acc.hByteStride +
                  (uint32)w               * wByteStride;

  return acc.ptr + offset;
}

// -----------------------------------------------------------------------------------------------
// TensorAccessor3D
// -----------------------------------------------------------------------------------------------

// Default
#if defined(OIDN_BNNS)
typedef TensorAccessor3D_chw TensorAccessor3D;
#else
typedef TensorAccessor3D_ChwBc TensorAccessor3D;
#endif

template<typename T>
inline float Tensor_get(const uniform TensorAccessor3D& acc, uniform int c, uniform int h, int w)
{
  return *((uniform T* varying)Tensor_getPtr<T>(acc, c, h, w));
}

template<typename T>
inline void Tensor_set(const uniform TensorAccessor3D& acc, uniform int c, uniform int h, int w,
                       float value)
{
  *((uniform T* varying)Tensor_getPtr<T>(acc, c, h, w)) = (T)value;
}

template<typename T>
inline vec3f Tensor_get3(const uniform TensorAccessor3D& acc, uniform int c, uniform int h, int w)
{
  return make_vec3f(Tensor_get<T>(acc, c,   h, w),
                    Tensor_get<T>(acc, c+1, h, w),
                    Tensor_get<T>(acc, c+2, h, w));
}

template<typename T>
inline void Tensor_set3(const uniform TensorAccessor3D& acc, uniform int c, uniform int h, int w,
                        const vec3f& value)
{
  Tensor_set<T>(acc, c,   h, w, value.x);
  Tensor_set<T>(acc, c+1, h, w, value.y);
  Tensor_set<T>(acc, c+2, h, w, value.z);
}

// -----------------------------------------------------------------------------------------------
// TensorAccessor4D_IOhwBiBo
// -----------------------------------------------------------------------------------------------

// Tensor in IOhwBiBo layout (blocked)
struct TensorAccessor4D_IOhwBiBo
{
  uniform int8* uniform ptr;
  uniform uint32 hByteStride;
  uniform uint32 OByteStride;
  uniform uint32 IByteStride;
  uniform int O, I, H, W;
};

template<typename T>
inline uniform int8* uniform Tensor_getPtr(const uniform TensorAccessor4D_IOhwBiBo& acc,
                                           uniform int o, uniform int i, uniform int h, uniform int w)
{
  const uniform uint32 B = getBlockC<T>();
  const uniform uint32 BoByteStride = sizeof(uniform T);
  const uniform uint32 BiByteStride = B * BoByteStride;
  const uniform uint32 wByteStride  = B * BiByteStride;

  uniform uint32 offset = ((uniform uint32)i / B) * acc.IByteStride +
                          ((uniform uint32)o / B) * acc.OByteStride +
                          (uniform uint32)h       * acc.hByteStride +
                          (uniform uint32)w       * wByteStride  +
                          ((uniform uint32)i % B) * BiByteStride +
                          ((uniform uint32)o % B) * BoByteStride;

  return acc.ptr + offset;
}

// -----------------------------------------------------------------------------------------------
// TensorAccessor4D_OIhwPoQiRoSi
// -----------------------------------------------------------------------------------------------

struct TensorAccessor4D_OIhwPoQiRoSi
{
  uniform int8* uniform ptr;
  uniform uint32 OByteStride;
};

template<typename T>
inline uniform int8* uniform Tensor_getPtr(const uniform TensorAccessor4D_OIhwPoQiRoSi& acc,
                                           uniform int o)
{
  const uniform uint32 B = getBlockC<T>();
  //assert(o % B == 0);

  uniform uint32 offset = ((uniform uint32)o / B) * acc.OByteStride;

  return acc.ptr + offset;
}